<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title>OData TC meeting #175 Thursday May 18, 2017</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
body{-webkit-font-smoothing:antialiased;font-family:Cambria,Arial,Verdana,sans-serif;margin:0} body {margin-left:2%}
body,p,td,div{color:#111;font-family:"Helvetica Neue",Helvetica,Arial,Verdana,sans-serif;/*word-wrap:break-word*/}
h1,h2,h3,h4,h5,h6{line-height:1.5em}
a{-webkit-transition:color .2s ease-in-out;color:#0d6ea1;text-decoration:none}
a:hover{color:#3593d9}.footnote{color:#0d6ea1;font-size:.8em;vertical-align:super}dd{margin-bottom:1em}
li>p:first-child{margin:0}ul ul,ul ol{margin-bottom:.4em}.poetry
pre{display:block;font-family:Georgia,Garamond,serif!important;font-size:110%!important;font-style:italic;line-height:1.6em;margin-left:1em}
.poetry pre code{font-family:Georgia,Garamond,serif!important}
sup,sub,a.footnote{font-size:1.4ex;height:0;line-height:1;position:relative;vertical-align:super}sub{vertical-align:sub;top:-1px}
p,h5{font-size:1.1429em;line-height:1.3125em;margin:1.3125em 0}dt,th{font-weight:700}p{margin:0.7ex 2.0em}pre{margin-left:4em;}
p.note{font-size:75%}
.code-like{font-family:monospace;font-size:120%!important}
@media print{body{overflow:auto}
#wrapper{background:#fff;color:#303030;font-size:85%;padding:10px;position:relative;text-indent:0}}
@media screen{/*::selection{background:rgba(157,193,200,.5)}*/.inverted{background:#333}
.inverted p,.inverted td,.inverted li,.inverted h1,.inverted h2,.inverted h3,.inverted h4,.inverted h5,.inverted h6,.inverted pre,.inverted code,.inverted th{color:#eee!important}
.inverted a{color:#fff;text-decoration:underline}#wrapper{padding:20px}.inverted #wrapper{background:#333}}
</style>
<!-- # grep -v excluding_those_lines __file__ |shasum -a 512 -->
<!-- sha512_excluding_those_lines='561ebd4457ab38742cf39c4367ae893885c13269c2bf510fda66fa2c9dd790ed480b0014e30c0b69b6dda5a4b8d1985853953946ae7aca924ff668ec6fc16bf9' -->
</head>
<body class="normal">
  <div id="wrapper">
<h1>OData TC meeting #175 Thursday May 18, 2017</h1>
<p>Acting chair: Mike</p>
<pre>Chat transcript from room: odatatc
2017-05-18 0800-1100 PDT
</pre>
<h2>1. Roll call</h2>

<h3>1.1 Members present</h3>

<pre>
    George Ericson (Dell)
    Gerald Krause (SAP SE)
    Mark Biamonte (Progress Software)
    Martin Zurmuehl (SAP SE)
    Matthew Borges (SAP SE) a.k.a. Matt
    Michael Pizzo (IBM) a.k.a. Mike
    Ralf Handl (SAP SE)
    Stefan Hagen (Individual)
</pre>

<p>Quorum achieved. Details cf. <a href="https://www.oasis-open.org/apps/org/workgroup/odata/event.php?event_id=43977">normative attendance sheet for this meeting (event_id=43977)</a>.</p>

<p>Notes taken by all and subsequently edited for readability by Stefan.</p>

<h2>2. Approve agenda</h2>
<p>Ralf: Gerald to share news on the Data Aggregation spec</p>
<p>Mike: new issue</p>
<p>Ralf: ODATA-1077 - Include atomicityGroup in JSON Batch Response</p>
<p>Ralf: ODATA-1076 - If-Match and If-None-Match: align wording with RFC7232</p>
<p>Mike: start with these two issues before document walkthrough</p>
<p>Ralf: Geralds topic after #3</p>
<p>Agenda is approved with these additions.</p>

<h2>3. Approve minutes from previous meeting(s)</h2>
<h3>3.1 Minutes from May 11, 2017 TC meeting #174</h3>
<p><a href="https://www.oasis-open.org/apps/org/workgroup/odata/download.php/60730/odata-meeting-174_on-20170511-minutes.html" rel="noopener noreferrer" target="_blank">https://www.oasis-open.org/apps/org/workgroup/odata/download.php/60730/odata-meeting-174_on-20170511-minutes.html</a></p>
<p>Minutes approved unchanged as published.</p>

<h2>4. New agenda item: Gerald on Data Aggregation</h2>
<p>Mike: Gerald introduced idea of new transformation for Data Aggregation.  Will send out a document that we can describe at a later meeting.</p>

<h2>5. Review action items [<a href="https://www.oasis-open.org/apps/org/workgroup/odata/members/action_items.php" rel="noopener noreferrer" target="_blank">Link to Action item list</a>]</h2>
<h3>5.1 Action items due</h3>
<p>None</p>

<h2>6. V4.01</h2>
<h3>6.1 Issues for V4.01_CSD02</h3>

<h4>6.1.1 <a href="https://issues.oasis-open.org/browse/ODATA-1076" rel="noopener noreferrer" target="_blank">ODATA-1076</a> - If-Match and If-None-Match: align wording with RFC7232</h4>
<p>Ralf: ODATA-1076 is OPEN</p>
<p>Mike: from RFC7232:</p>
<pre>
2.3.2.  Comparison

   There are two entity-tag comparison functions, depending on whether
   or not the comparison context allows the use of weak validators:

   o  Strong comparison: two entity-tags are equivalent if both are not
      weak and their opaque-tags match character-by-character.

   o  Weak comparison: two entity-tags are equivalent if their
      opaque-tags match character-by-character, regardless of either or
      both being tagged as "weak".









Fielding &amp; Reschke           Standards Track                   [Page 10]

 
RFC 7232              HTTP/1.1 Conditional Requests            June 2014


   The example below shows the results for a set of entity-tag pairs and
   both the weak and strong comparison function results:

   +--------+--------+-------------------+-----------------+
   | ETag 1 | ETag 2 | Strong Comparison | Weak Comparison |
   +--------+--------+-------------------+-----------------+
   | W/"1"  | W/"1"  | no match          | match           |
   | W/"1"  | W/"2"  | no match          | no match        |
   | W/"1"  | "1"    | no match          | match           |
   | "1"    | "1"    | match             | match           |
   +--------+--------+-------------------+-----------------+
</pre>

<p>Mike: From RFC7232: </p>
<pre>
   An origin server MUST use the strong comparison function when
   comparing entity-tags for If-Match (Section 2.3.2), since the client
   intends this precondition to prevent the method from being applied if
   there have been any changes to the representation data.
</pre>

<p>Mike: Section 3.2 says use weak for If-None-Match:</p>
<pre>
   A recipient MUST use the weak comparison function when comparing
   entity-tags for If-None-Match (Section 2.3.2), since weak entity-tags
   can be used for cache validation even if there have been changes to
   the representation data.
</pre>

<p>Martin: From RFC7232:</p>
<pre>
   An entity-tag can be either a weak or strong validator, with strong
   being the default.  If an origin server provides an entity-tag for a
   representation and the generation of that entity-tag does not satisfy
   all of the characteristics of a strong validator (Section 2.1), then
   the origin server MUST mark the entity-tag as weak by prefixing its
   opaque value with "W/" (case-sensitive).
</pre>

<p>Mike: Section 2.1: </p>
<pre>
2.1.  Weak versus Strong

   Validators come in two flavors: strong or weak.  Weak validators are
   easy to generate but are far less useful for comparisons.  Strong
   validators are ideal for comparisons but can be very difficult (and
   occasionally impossible) to generate efficiently.  Rather than impose
   that all forms of resource adhere to the same strength of validator,
   HTTP exposes the type of validator in use and imposes restrictions on
   when weak validators can be used as preconditions.

   A "strong validator" is representation metadata that changes value
   whenever a change occurs to the representation data that would be
   observable in the payload body of a 200 (OK) response to GET.

   A strong validator might change for reasons other than a change to
   the representation data, such as when a semantically significant part
   of the representation metadata is changed (e.g., Content-Type), but
   it is in the best interests of the origin server to only change the
   value when it is necessary to invalidate the stored responses held by
   remote caches and authoring tools.

   Cache entries might persist for arbitrarily long periods, regardless
   of expiration times.  Thus, a cache might attempt to validate an
   entry using a validator that it obtained in the distant past.  A
   strong validator is unique across all versions of all representations
   associated with a particular resource over time.  However, there is
   no implication of uniqueness across representations of different
   resources (i.e., the same strong validator might be in use for
   representations of multiple resources at the same time and does not
   imply that those representations are equivalent).






Fielding &amp; Reschke           Standards Track                    [Page 5]

 
RFC 7232              HTTP/1.1 Conditional Requests            June 2014


   There are a variety of strong validators used in practice.  The best
   are based on strict revision control, wherein each change to a
   representation always results in a unique node name and revision
   identifier being assigned before the representation is made
   accessible to GET.  A collision-resistant hash function applied to
   the representation data is also sufficient if the data is available
   prior to the response header fields being sent and the digest does
   not need to be recalculated every time a validation request is
   received.  However, if a resource has distinct representations that
   differ only in their metadata, such as might occur with content
   negotiation over media types that happen to share the same data
   format, then the origin server needs to incorporate additional
   information in the validator to distinguish those representations.

   In contrast, a "weak validator" is representation metadata that might
   not change for every change to the representation data.  This
   weakness might be due to limitations in how the value is calculated,
   such as clock resolution, an inability to ensure uniqueness for all
   possible representations of the resource, or a desire of the resource
   owner to group representations by some self-determined set of
   equivalency rather than unique sequences of data.  An origin server
   SHOULD change a weak entity-tag whenever it considers prior
   representations to be unacceptable as a substitute for the current
   representation.  In other words, a weak entity-tag ought to change
   whenever the origin server wants caches to invalidate old responses.

   For example, the representation of a weather report that changes in
   content every second, based on dynamic measurements, might be grouped
   into sets of equivalent representations (from the origin server's
   perspective) with the same weak validator in order to allow cached
   representations to be valid for a reasonable period of time (perhaps
   adjusted dynamically based on server load or weather quality).
   Likewise, a representation's modification time, if defined with only
   one-second resolution, might be a weak validator if it is possible
   for the representation to be modified twice during a single second
   and retrieved between those modifications.

   Likewise, a validator is weak if it is shared by two or more
   representations of a given resource at the same time, unless those
   representations have identical representation data.  For example, if
   the origin server sends the same validator for a representation with
   a gzip content coding applied as it does for a representation with no
   content coding, then that validator is weak.  However, two
   simultaneous representations might share the same strong validator if
   they differ only in the representation metadata, such as when two
   different media types are available for the same representation data.





Fielding &amp; Reschke           Standards Track                    [Page 6]

 
RFC 7232              HTTP/1.1 Conditional Requests            June 2014


   Strong validators are usable for all conditional requests, including
   cache validation, partial content ranges, and "lost update"
   avoidance.  Weak validators are only usable when the client does not
   require exact equality with previously obtained representation data,
   such as when validating a cache entry or limiting a web traversal to
   recent changes.
</pre>

<p>Mike: Potential issue: according to strict reading of RFC7232, it appears that returning the same etag when $select, $apply, or $expand is applied (which is what we would want) would imply that the etag was weak.</p>
<p>Ralf: </p>
<pre>
Because these are specified in the query string it's really a different URL...
ETags and $expand work different than HTTP ETags in general: 
 each expanded entity has its own ETag in the @odata.etag annotation
So in a response representing a single entity with expanded entities, 
 each entity could have a @odata.etag, which is the strong ETag,
 and the overall response in the ETag header could have 
 either a weak ETag computed from the "main" entity, 
 or a strong ETag computed collision-free from all involved @odata.etags
Similar for collection-valued responses
</pre>
<p>Mike: <a href="https://tools.ietf.org/html/rfc7232" rel="noopener noreferrer" target="_blank">https://tools.ietf.org/html/rfc7232</a></p>
<p>Ralf: Will prepare proposal based on this discussion</p>

<h4>6.1.2 <a href="https://issues.oasis-open.org/browse/ODATA-1077" rel="noopener noreferrer" target="_blank">ODATA-1077</a> - Include atomicityGroup in JSON Batch Response</h4>

<p>Ralf: ODATA-1077 is OPEN</p>
<p><b>Mark</b>: I <b>move</b> that OData-1077 be resolved as proposed. <b>Mike</b> seconds.</p>
<p>Ralf: ODATA-1077 is RESOLVED as proposed</p>


<h4 id="sect_6_1_3">6.1.3 <a href="https://issues.oasis-open.org/browse/ODATA-1078" rel="noopener noreferrer" target="_blank">ODATA-1078</a> - What happens if lambda variable name matches a (complex) property name?</h4>

<p>Ralf: ODATA-1078 is OPEN</p>
<p>Mike: Proposal:</p>
<pre>
1) It is not required 
2) In case of conflict, lambda variable name wins (you shouldn't pick a lambda variable name that conflicts...)
</pre>
<p>Mike: Also; client can always use $it to "back out of" shadowing...</p>
<p><b>Mark</b>: I <b>move</b> to resolve OData-1078 as proposed. <b>Mike</b> seconds.</p>
<p>Ralf: ODATA-1078 is RESOLVED as proposed</p>

<h3>6.2 Document walkthrough</h3>

<h4>6.2.1 Part 1: Protocol</h4>
<p>URL = <a href="https://www.oasis-open.org/committees/download.php/60437/odata-v4.01-wd02-part1-protocol-2017-04-05.docx" rel="noopener noreferrer" target="_blank">https://www.oasis-open.org/committees/download.php/60437/odata-v4.01-wd02-part1-protocol-2017-04-05.docx</a></p>
<p>Finished already.</p>

<h4>6.2.2 Part 2: URL Conventions</h4>
<p>URL = <a href="https://www.oasis-open.org/committees/download.php/60438/odata-v4.01-wd02-part2-url-conventions-2017-04-05.docx" rel="noopener noreferrer" target="_blank">https://www.oasis-open.org/committees/download.php/60438/odata-v4.01-wd02-part2-url-conventions-2017-04-05.docx</a></p>
<p>All walk through the document, discuss and perform online changes during the meeting.</p>

<p>Ralf: Continue with section 5.1.1.5, String Functions</p>
<p>Mike: [1,1,2] subsetof [1,2]?</p>
<p>Ralf: [3,1,4] subsetof [4,3,1]?</p>
<p>Mike: </p>
<pre>
Does it depend on whether the collection is ordered?
I would think that, for ordered or non-ordered, the element of the left operand must occur at least as many times in the right operand.
For non-ordered collections, [3,1] subsetof [4,1,3] should be true.
Question is for ordered collections: is [3,1] subsetof [4,1,3]
</pre>
<p>Mike: Reopened <a href="https://issues.oasis-open.org/browse/ODATA-1002" rel="noopener noreferrer" target="_blank">ODATA-1002</a>, assigned to Hubert with the following comment:<br>
In reviewing the application, two questions came up:</p>
<pre>
1) is [1,1,2] subsetof [1,2] ?  (do elements of the left operand have to occur at least as many times in the right operand)
2) is [3,1] subsetof [4,1,3]? (does order matter)

For #2, if the collections are unordered, then [3,1] subsetof [4,1,3] should be true, but what about for ordered collections?
</pre>

<p>Ralf: 5.1.1.10 Lambda Operators</p>
<p>Mike: Created new issue  <a href="https://issues.oasis-open.org/browse/ODATA-1078" rel="noopener noreferrer" target="_blank">ODATA-1078</a> - What happens if lambda variable name matches a (complex) property name?</p>
<p>Cf. section <a href="#sect_6_1_3">6.1.3</a> above in issue section for processing.</p>
<p>Completed</p>


<h4>6.2.3 JSON Format</h4>
<p>URL = <a href="https://www.oasis-open.org/committees/download.php/60365/odata-json-format-v4.01-wd02-2017-03-24.docx" rel="noopener noreferrer" target="_blank">https://www.oasis-open.org/committees/download.php/60365/odata-json-format-v4.01-wd02-2017-03-24.docx</a></p>
<p>Completed</p>

<h4>6.2.4 CSDL JSON Representation</h4>
<p>URL = <a href="https://www.oasis-open.org/committees/download.php/60500/odata-csdl-json-v4.01-wd01-2017-04-10.docx" rel="noopener noreferrer" target="_blank">https://www.oasis-open.org/committees/download.php/60500/odata-csdl-json-v4.01-wd01-2017-04-10.docx</a></p>
<p>Skipped</p>

<h4>6.2.5 CSDL XML Representation</h4>
<p>URL = <a href="https://www.oasis-open.org/committees/download.php/60499/odata-csdl-xml-v4.01-wd02-2017-04-10.docx" rel="noopener noreferrer" target="_blank">https://www.oasis-open.org/committees/download.php/60499/odata-csdl-xml-v4.01-wd02-2017-04-10.docx</a></p>
<p>Skipped - <b>Note</b>: Planned to start with this next meeting!</p>

<h4>6.2.6 New in OData 4.01</h4>
<p>URL = <a href="https://www.oasis-open.org/committees/download.php/60439/new-in-odata-v4.01-wd01-2017-04-05.docx" rel="noopener noreferrer" target="_blank">https://www.oasis-open.org/committees/download.php/60439/new-in-odata-v4.01-wd01-2017-04-05.docx</a></p>
<p>Skipped</p>


<h2>7. Next meetings</h2>
<p>Mike: skip next meeting [which was scheduled for May 25, 2017] and use time to pre-read CSDL documents (both of them)</p>
<p>Mark: Agrees.</p>

<h3>7.1 Next Meeting on Thursday June 01, 2017 during 7-10 am PDT (16:00-19:00 CEST)</h3> 
<p>All will prepare to start walking through the CSDL XML Representation in that meeting.</p>

<h3>7.2 Meeting after that on Thursday June 08, 2017 during 8-11 am PDT (17:00-20:00 CEST)</h3> 
<p>Mark: On vacation.</p>

<h2>8. AOB and wrap up</h2>
<p>None</p>

<p>Meeting adjourned by chair.</p>

</div>
</body>
</html>
