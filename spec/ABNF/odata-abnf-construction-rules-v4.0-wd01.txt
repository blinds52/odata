;------------------------------------------------------------------------------
; odata-abnf-v4.0-wd01
;------------------------------------------------------------------------------
;
; Technical Committee:
;   OASIS Open Data Protocol (OData) TC
;
; Chairs:
;   - Barbara Hartel (barbara.hartel@sap.com), SAP AG
;   - Ram Jeyaraman (Ram.Jeyaraman@microsoft.com), Microsoft
;
; Editors:
;   - Ralf Handl (ralf.handl@sap.com), SAP AG
;   - Michael Pizzo (mikep@microsoft.com), Microsoft
;
; Additional artifacts:
;   This prose specification is one component of a Work Product which consists
;   of:
;   - OData Core Part 1: Protocol
;   - OData Core Part 2: URL Conventions
;   - OData Core Part 3: Common Schema Definition Language
;   - OData ABNF Construction Rules (this document)
;
; Related work:
;   This work product is related to the following two Work Products, each of 
;   which define alternate formats for OData payloads
;   - OData JSON Format
;   - OData ATOM Format
;   This specification replaces or supersedes:
;   - None
;
; Declared XML namespaces:
;   - None
;
; Abstract:
;   The Open Data Protocol (OData) enables the creation of REST-based data
;   services, which allow resources, identified using Uniform Resource
;   Identifiers (URLs) and defined in a data model, to be published and 
;   edited by Web clients using simple HTTP messages. This document defines
;   the URL syntax for requests and the serialization format for primitive 
;   literals in request and response payloads.
;
; Status:
;   This Working Draft (WD) has been produced by one or more TC Members; it has
;   not yet been voted on by the TC or approved as a Committee Draft (Committee
;   Specification Draft or a Committee Note Draft). The OASIS document Approval
;   Process begins officially with a TC vote to approve a WD as a Committee
;   Draft. A TC may approve a Working Draft, revise it, and re-approve it any
;   number of times as a Committee Draft.
;
;
; Overview:
;   This grammar uses the ABNF defined in RFC5234 with one extension: literals 
;   enclosed in single quotes (e.g. '$metadata') are treated case-sensitive. 
;
;   The following rules assume that URIs have been percent-encoding normalized
;   as described in section 6.2.2.2 of RFC3986 
;   (http://tools.ietf.org/html/rfc3986#section-6.2.2.2)
;   before applying the grammar to them, i.e. all characters in the unreserved 
;   set (see rule "unreserved" below) are plain literals and NOT
;   percent-encoded. 
;
;   For characters outside the unreserved set the rules explicitly state 
;   whether the percent-encoded representation is treated identical to the
;   plain literal representation.
; 
;   One prominent example is the single quote that delimits OData primitive  
;   type literals: %27 and ' are treated identically, so a single quote within 
;   a string literal is "encoded" as two consecutive single quotes in either
;   literal or percent-encoded representation.
;
; Contents:
;   1. Resource Path
;   2. Query Options
;   3. Expressions
;   4. JSON format for function parameters
;   5. Names and identifiers
;   6. Literal Data Values
;   7. Punctuation
;
;   A. URI syntax [RFC3986]
;   B. ABNF core definitions [RFC5234]
;   C. UTF-8 syntax [RFC3629]
;
;------------------------------------------------------------------------------

odataUri = ( "https" / "http" ) "://" host [ ":" port ] 
           serviceRoot
           [ '$metadata' / '$batch' / odataRelativeUri ]  
           [ [ namespace "." entityContainer ] "?" search ]  

serviceRoot = "/" *( segment-nz "/" )

odataRelativeUri = resourcePath [ "?" queryOptions ]


;------------------------------------------------------------------------------
; 1. Resource Path
;------------------------------------------------------------------------------

resourcePath = [ containerQualifier ] entitySetName [ collectionNavigation ] 
             / [ containerQualifier ] namedEntity   [ singleNavigation ]
             / actionImportCall 
             / entityColFunctionImportCall    [ collectionNavigation ] 
             / entityFunctionImportCall       [ singleNavigation ] 
             / complexColFunctionImportCall   [ collectionPath ] 
             / complexFunctionImportCall      [ complexPath ] 
             / primitiveColFunctionImportCall [ collectionPath ] 
             / primitiveFunctionImportCall    [ singlePath ] 

collectionNavigation = [ "/" qualifiedEntityTypeName ]
                       ( keyPredicate [ singleNavigation ]
                       / collectionPath
                       / ref
                       / ""     ; for restricting to a derived entity type
                       )

keyPredicate     = simpleKey / compoundKey
simpleKey        = OPEN keyPropertyValue CLOSE
compoundKey      = OPEN keyValuePair *( COMMA keyValuePair ) CLOSE
keyValuePair     = primitiveKeyProperty EQ keyPropertyValue
keyPropertyValue = primitiveLiteral

singleNavigation = [ "/" qualifiedEntityTypeName ] 
                   ( "/" propertyPath
                   / boundOperation
                   / ref 
                   / value  ; request the media resource of a media entity 
                   / ""     ; type cast after key access
                   )

propertyPath = entityColNavigationProperty [ collectionNavigation ]
             / entityNavigationProperty    [ singleNavigation ]
             / complexColProperty          [ collectionPath ]
             / complexProperty             [ complexPath ]
             / primitiveColProperty        [ collectionPath ]
             / primitiveProperty           [ singlePath ]
             / streamProperty 

collectionPath = count / boundOperation
singlePath     = value / boundOperation

complexPath    = [ "/" qualifiedComplexTypeName ] 
                 ( "/" propertyPath 
                 / boundOperation
                 )

count = '/$count'
ref   = '/$ref'
value = '/$value'

; boundOperation segments can only be composed if the type of the previous segment 
; matches the type of the first parameter of the action or function being called.
boundOperation = "/" ( boundActionCall
                     / boundEntityColFuncCall    [ collectionNavigation ] 
                     / boundEntityFuncCall       [ singleNavigation ] 
                     / boundComplexColFuncCall   [ collectionPath ] 
                     / boundComplexFuncCall      [ complexPath ]
                     / boundPrimitiveColFuncCall [ collectionPath ] 
                     / boundPrimitiveFuncCall    [ singlePath ] 
                     )

actionImportCall = [ containerQualifier ] actionImport [ "()" ]
boundActionCall  = namespace "." action [ "()" ]
                   ; with the added restriction that the binding parameter MUST be either an entity or collection of entities
                   ; and is specified by reference using the URI immediately preceding (to the left) of the boundActionCall

; The following boundXxxFuncCall rules have the added restrictions that
;  - the function MUST support binding, and 
;  - the binding parameter type MUST match the type of resource identified by the 
;    URI immediately preceding (to the left) of the boundXxxFuncCall, and
;  - the functionParameters MUST NOT include the bindingParameter.
boundEntityFuncCall       = namespace "." entityFunction       functionParameters
boundEntityColFuncCall    = namespace "." entityColFunction    functionParameters
boundComplexFuncCall      = namespace "." complexFunction      functionParameters
boundComplexColFuncCall   = namespace "." complexColFunction   functionParameters
boundPrimitiveFuncCall    = namespace "." primitiveFunction    functionParameters
boundPrimitiveColFuncCall = namespace "." primitiveColFunction functionParameters

entityFunctionImportCall       = [ containerQualifier ] entityFunctionImport       [ functionParameters ]
entityColFunctionImportCall    = [ containerQualifier ] entityColFunctionImport    [ functionParameters ]
complexFunctionImportCall      = [ containerQualifier ] complexFunctionImport      [ functionParameters ]
complexColFunctionImportCall   = [ containerQualifier ] complexColFunctionImport   [ functionParameters ]
primitiveFunctionImportCall    = [ containerQualifier ] primitiveFunctionImport    [ functionParameters ]
primitiveColFunctionImportCall = [ containerQualifier ] primitiveColFunctionImport [ functionParameters ]

functionParameters    = OPEN [ functionParameter *( COMMA functionParameter ) ] CLOSE
functionParameter     = functionParameterName EQ ( parameterAlias / primitiveLiteral )
functionParameterName = odataIdentifier
parameterAlias        = AT odataIdentifier

containerQualifier = namespace "." entityContainer "."


;------------------------------------------------------------------------------
; 2. Query Options
;------------------------------------------------------------------------------

queryOptions = queryOption *( "&" queryOption )        
queryOption  = systemQueryOption  
             / aliasAndValue 
             / parameterNameAndValue
             / customQueryOption  

systemQueryOption = aggregate
                  / expand 
                  / filter 
                  / format 
                  / orderby 
                  / skip 
                  / top 
                  / inlinecount 
                  / search
                  / select 
                  / skiptoken

; TODO: adapt to new syntax
aggregate         = '$aggregate' EQ aggregateCommand *( SEMI aggregateCommand )
aggregateCommand  = aggregateClause 
                  / filter 
                  / expand 
aggregateClause   = aggregateList [ RWS "$groupby" RWS groupbyList ]
                  / '$groupby' RWS groupbyList
aggregateList     = aggregateItem *( COMMA aggregateItem )
aggregateItem     = property [ RWS "as" RWS dynamicProperty ]
                  / aggregateFunction OPEN property CLOSE [ RWS 'as' RWS dynamicProperty ]
                  / 'count(' [ property / navigationProperty ]  ')' RWS 'as' RWS dynamicProperty
                  / 'countDistinct(' ( property / navigationProperty ) ')' RWS 'as' RWS dynamicProperty
                  / *( navigationProperty "/" ) OPEN aggregateList CLOSE
                  / *( navigationProperty "/" ) property
                  / *( navigationProperty "/" ) aggregateFunction OPEN property CLOSE 
groupbyList       = groupbyItem *( COMMA groupbyItem )
groupbyItem       = property
                  / ( complexProperty / navigationProperty ) "/" OPEN groupbyList CLOSE
                  / ( complexProperty / navigationProperty ) [ "/" groupbyItem ] 
dynamicProperty   = odataIdentifier
aggregateFunction = 'sum' / 'min' / 'max' / 'average'

expand       = '$expand' EQ expandItem *( COMMA expandItem )
expandItem   = [ qualifiedEntityTypeName "/" ] navigationProperty 
               [ "/" qualifiedEntityTypeName ]
               [ OPEN expandOption *( SEMI expandOption ) CLOSE ]
               [ ref ]
expandOption = filter
             / search
             / select 
             / orderby
             / skip 
             / top 
             / inlinecount
             / expand
             / levels
             
levels = '$levels' EQ ( 1*DIGIT / 'max' )

filter = '$filter' EQ boolCommonExpr

orderby     = '$orderby' EQ orderbyItem *( COMMA orderbyItem )
orderbyItem = commonExpr [ RWS ( 'asc' / 'desc' ) ]

skip = '$skip' EQ 1*DIGIT
top  = '$top'  EQ 1*DIGIT

format = '$format' EQ
         ( 'atom'
         / 'json' 
         / 'xml'
         / 1*( pchar / "/" ) ; <a data service specific value indicating a
         )                   ; format specific to the specific data service> or
                             ; <An IANA-defined [IANA-MMT] content type>
                          
inlinecount = '$inlinecount' EQ ( 'allpages' / 'none' )

search     = '$search' EQ BWS searchExpr
searchExpr = ( OPEN BWS searchExpr BWS CLOSE
             / searchTerm 
             ) [ searchOrExpr
               / searchAndExpr
               ]

searchOrExpr  = RWS 'OR'  RWS searchExpr
searchAndExpr = RWS [ 'AND' RWS ] searchExpr

searchTerm   = [ 'NOT' RWS ] ( searchPhrase / searchWord )
searchPhrase = quotation-mark 1*qchar-no-AMP-DQUOTE quotation-mark
searchWord   = 1*ALPHA ; TODO: any character from the Unicode categories L or Nl, 
                       ;       but not the words AND, OR, and NOT

select     = '$select' EQ selectItem *( COMMA selectItem )
selectItem = STAR  
           / allOperationsInSchema 
           / [ qualifiedEntityTypeName "/" ] 
             ( navigationProperty  
             / *( ( complexProperty / complexColProperty ) "/"
                  [ qualifiedComplexTypeName "/" ] 
                ) property 
             / qualifiedActionName  
             / qualifiedFunctionName  
             )
allOperationsInSchema = namespace "." STAR                 

; The parameterTypeNames are required to uniquely identify the action or function
; only if it has overloads.
qualifiedActionName   = namespace "." action   [ OPEN parameterTypeNames CLOSE ]
qualifiedFunctionName = namespace "." function [ OPEN parameterTypeNames CLOSE ]

; The types of all the parameters to the corresponding function 
; in the order they are declared in the function.
parameterTypeNames = [ parameterTypeName *( COMMA parameterTypeName ) ]
parameterTypeName  = qualifiedTypeName 

skiptoken = '$skiptoken' EQ 1*( qchar-no-AMP )

aliasAndValue         = parameterAlias        EQ parameterValue
parameterNameAndValue = functionParameterName EQ parameterValue

parameterValue = complexInUri  
               / complexColInUri
               / entityReference
               / entityRefColInUri
               / primitiveLiteral
               / primitiveColInUri
               
entityReference = 'KEY(' 
                  [ entityContainer "." ] entitySetName keyPredicate
                  [ "/" qualifiedEntityTypeName ]
                  CLOSE                

customQueryOption = customName [ EQ customValue ]
customName        = qchar-no-AMP-EQ-AT-DOLLAR *( qchar-no-AMP-EQ ) 
customValue       = *( qchar-no-AMP )


;------------------------------------------------------------------------------
; 3. Expressions
;------------------------------------------------------------------------------

; TODO: is a boolCommonExpr also a commonExpr? To e.g. sort by Boolean?
commonExpr = ( primitiveLiteral
             / parameterAlias
             / firstMemberExpr
             / functionExpr
             / negateExpr 
             / methodCallExpr 
             / parenExpr 
             / castExpr 
             ) 
             [ addExpr 
             / subExpr 
             / mulExpr 
             / divExpr 
             / modExpr
             ]  

boolCommonExpr = ( isofExpr 
                 / boolMethodCallExpr 
                 / notExpr  
                 / commonExpr
                   [ eqExpr 
                   / neExpr 
                   / ltExpr  
                   / leExpr  
                   / gtExpr 
                   / geExpr 
                   / hasExpr 
                   ]
                 / boolParenExpr
                 ) [ andExpr / orExpr ] 

; TODO: this may be too generous: did we intend to allow arbitrary member expressions as function parameters?
firstMemberExpr = [ lambdaPredicatePrefixExpr ]  ; only allowed inside a lambdaPredicateExpr
                  memberExpr

memberExpr = [ qualifiedEntityTypeName "/" ]
             ( propertyPathExpr
             / boundFunctionExpr 
             )
             
propertyPathExpr = ( entityColNavigationProperty [ collectionNavigationExpr ] 
                 / entityNavigationProperty    [ singleNavigationExpr ] 
                 / complexColProperty          [ collectionPathExpr ]
                 / complexProperty             [ complexPathExpr ] 
                 / primitiveColProperty        [ collectionPathExpr ]
                 / primitiveProperty           [ singlePathExpr ]
                 / streamProperty              ; TODO: do we allow bindable functions that take an Edm.Stream as input?
                 )
                   
lambdaPredicatePrefixExpr = inscopeVariableExpr "/"
inscopeVariableExpr       = implicitVariableExpr / lambdaVariableExpr
implicitVariableExpr      = "$it" ; references the unnamed outer variable of the query
lambdaVariableExpr        = odataIdentifier

collectionNavigationExpr = count
                         / "/" [ qualifiedEntityTypeName "/" ] 
                           ( boundFunctionExpr 
                           / anyExpr
                           / allExpr 
                           )

singleNavigationExpr = "/" memberExpr

collectionPathExpr = count 
                   / "/" boundFunctionExpr
                   / "/" anyExpr
                   / "/" allExpr
 
complexPathExpr = "/" [ qualifiedComplexTypeName "/" ]
                  ( propertyPathExpr 
                  / boundFunctionExpr 
                  )

singlePathExpr = "/" boundFunctionExpr

boundFunctionExpr = functionExpr ; boundFunction segments can only be composed if the type of the    
                                 ; previous segment matches the type of the first function parameter
                                     
functionExpr = namespace "."
               ( entityColFunction    functionExprParameters [ collectionNavigationExpr ] 
               / entityFunction       functionExprParameters [ singleNavigationExpr ] 
               / complexColFunction   functionExprParameters [ collectionPathExpr ]
               / complexFunction      functionExprParameters [ complexPathExpr ] 
               / primitiveColFunction functionExprParameters [ collectionPathExpr ] 
               / primitiveFunction    functionExprParameters [ singlePathExpr ] 
               )

functionExprParameters = OPEN [ functionExprParameter *( COMMA functionExprParameter ) ] CLOSE
functionExprParameter  = functionParameterName EQ ( parameterValue / parameterAlias / firstMemberExpr )

anyExpr = 'any' OPEN BWS [ lambdaVariableExpr BWS COLON BWS lambdaPredicateExpr ] BWS CLOSE
allExpr = 'all' OPEN BWS   lambdaVariableExpr BWS COLON BWS lambdaPredicateExpr   BWS CLOSE
lambdaPredicateExpr = boolCommonExpr ; containing at least one lambdaPredicatePrefixExpr

methodCallExpr = indexOfMethodCallExpr 
               / toLowerMethodCallExpr 
               / toUpperMethodCallExpr  
               / trimMethodCallExpr 
               / substringMethodCallExpr 
               / concatMethodCallExpr 
               / lengthMethodCallExpr 
               / yearMethodCallExpr 
               / monthMethodCallExpr 
               / dayMethodCallExpr 
               / hourMethodCallExpr 
               / minuteMethodCallExpr 
               / secondMethodCallExpr 
               / fractionalsecondsMethodCallExpr
               / totalsecondsMethodCallExpr
               / dateMethodCallExpr 
               / timeMethodCallExpr 
               / roundMethodCallExpr 
               / floorMethodCallExpr 
               / ceilingMethodCallExpr 
               / distanceMethodCallExpr 
               / geoLengthMethodCallExpr 
               / totalOffsetMinutesMethodCallExpr
               / minDateTimeMethodCallExpr
               / maxDateTimeMethodCallExpr
               / nowMethodCallExpr
               / searchMethodCallExpr

boolMethodCallExpr = endsWithMethodCallExpr 
                   / startsWithMethodCallExpr 
                   / substringOfMethodCallExpr                                          
                   / intersectsMethodCallExpr 

substringOfMethodCallExpr = 'substringof' OPEN BWS commonExpr BWS COMMA BWS commonExpr BWS CLOSE
startsWithMethodCallExpr  = 'startswith'  OPEN BWS commonExpr BWS COMMA BWS commonExpr BWS CLOSE
endsWithMethodCallExpr    = 'endswith'    OPEN BWS commonExpr BWS COMMA BWS commonExpr BWS CLOSE
lengthMethodCallExpr      = 'length'      OPEN BWS commonExpr BWS CLOSE
indexOfMethodCallExpr     = 'indexof'     OPEN BWS commonExpr BWS COMMA BWS commonExpr BWS CLOSE
substringMethodCallExpr   = 'substring'   OPEN BWS commonExpr BWS COMMA BWS commonExpr [ BWS COMMA BWS commonExpr BWS ] CLOSE
toLowerMethodCallExpr     = 'tolower'     OPEN BWS commonExpr BWS CLOSE
toUpperMethodCallExpr     = 'toupper'     OPEN BWS commonExpr BWS CLOSE
trimMethodCallExpr        = 'trim'        OPEN BWS commonExpr BWS CLOSE
concatMethodCallExpr      = 'concat'      OPEN BWS commonExpr BWS COMMA BWS commonExpr BWS CLOSE

yearMethodCallExpr               = 'year'               OPEN BWS commonExpr BWS CLOSE
monthMethodCallExpr              = 'month'              OPEN BWS commonExpr BWS CLOSE
dayMethodCallExpr                = 'day'                OPEN BWS commonExpr BWS CLOSE
hourMethodCallExpr               = 'hour'               OPEN BWS commonExpr BWS CLOSE
minuteMethodCallExpr             = 'minute'             OPEN BWS commonExpr BWS CLOSE
secondMethodCallExpr             = 'second'             OPEN BWS commonExpr BWS CLOSE
fractionalsecondsMethodCallExpr  = 'fractionalseconds'  OPEN BWS commonExpr BWS CLOSE
totalsecondsMethodCallExpr       = 'totalseconds'       OPEN BWS commonExpr BWS CLOSE
dateMethodCallExpr               = 'date'               OPEN BWS commonExpr BWS CLOSE
timeMethodCallExpr               = 'time'               OPEN BWS commonExpr BWS CLOSE
totalOffsetMinutesMethodCallExpr = 'totaloffsetminutes' OPEN BWS commonExpr BWS CLOSE 

minDateTimeMethodCallExpr = 'mindatetime(' BWS ')'
maxDateTimeMethodCallExpr = 'maxdatetime(' BWS ')'
nowMethodCallExpr         = 'now(' BWS ')'

searchMethodCallExpr = 'search' OPEN BWS commonExpr BWS COMMA BWS commonExpr BWS CLOSE

roundMethodCallExpr   = 'round'   OPEN BWS commonExpr BWS CLOSE
floorMethodCallExpr   = 'floor'   OPEN BWS commonExpr BWS CLOSE
ceilingMethodCallExpr = 'ceiling' OPEN BWS commonExpr BWS CLOSE

distanceMethodCallExpr   = 'geo.distance'   OPEN BWS commonExpr BWS COMMA BWS commonExpr BWS CLOSE
geoLengthMethodCallExpr  = 'geo.length'     OPEN BWS commonExpr BWS CLOSE
intersectsMethodCallExpr = 'geo.intersects' OPEN BWS commonExpr BWS COMMA BWS commonExpr BWS CLOSE

boolParenExpr = OPEN BWS boolCommonExpr BWS CLOSE
parenExpr     = OPEN BWS commonExpr     BWS CLOSE

andExpr = RWS 'and' RWS boolCommonExpr
orExpr  = RWS 'or'  RWS boolCommonExpr

eqExpr = RWS 'eq' RWS commonExpr     
neExpr = RWS 'ne' RWS commonExpr
ltExpr = RWS 'lt' RWS commonExpr
leExpr = RWS 'le' RWS commonExpr
gtExpr = RWS 'gt' RWS commonExpr
geExpr = RWS 'ge' RWS commonExpr

hasExpr = RWS 'has' RWS commonExpr

addExpr = RWS 'add' RWS commonExpr
subExpr = RWS 'sub' RWS commonExpr
mulExpr = RWS 'mul' RWS commonExpr
divExpr = RWS 'div' RWS commonExpr
modExpr = RWS 'mod' RWS commonExpr

negateExpr = "-" BWS commonExpr

notExpr = 'not' RWS boolCommonExpr

isofExpr = 'isof' OPEN BWS [ commonExpr BWS COMMA BWS ] qualifiedTypeName BWS CLOSE
castExpr = 'cast' OPEN BWS [ commonExpr BWS COMMA BWS ] qualifiedTypeName BWS CLOSE


;------------------------------------------------------------------------------
; 4. JSON format for function parameters
;------------------------------------------------------------------------------
; Note: the query part of a URI needs to be partially percent-decoded before
; applying these rules, see comment at the top of this file

complexColInUri = begin-array 
                  [ complexInUri *( value-separator complexInUri ) ] 
                  end-array
                  
complexInUri = begin-object
               [ ( complexTypeMetadataInUri  
                 / primitivePropertyInUri 
                 / complexPropertyInUri 
                 / collectionPropertyInUri  
                 )
                 *( value-separator 
                    ( primitivePropertyInUri 
                    / complexPropertyInUri 
                    / collectionPropertyInUri  
                    ) 
                  )
               ]  
               end-object

collectionPropertyInUri = ( quotation-mark primitiveColProperty quotation-mark 
                            name-separator 
                            primitiveColInUri 
                          ) 
                        / ( quotation-mark complexColProperty quotation-mark 
                            name-separator 
                            complexColInUri
                          )

primitiveColInUri = begin-array 
                    [ primitiveLiteralInJSON *( value-separator primitiveLiteralInJSON ) ] 
                    end-array
                    
complexPropertyInUri = quotation-mark complexProperty quotation-mark 
                       name-separator 
                       complexInUri
                            
complexTypeMetadataInUri = typeNVPInUri

typeNVPInUri = quotation-mark 'odata.type' quotation-mark
               name-separator
               quotation-mark qualifiedTypeName quotation-mark

primitivePropertyInUri = quotation-mark primitiveProperty quotation-mark 
                         name-separator 
                         primitiveLiteralInJSON

entityRefColInUri = begin-array
                    [ entityRefInJSON *( value-separator entityRefInJSON ) ]
                    end-array
entityRefInJSON   = quotation-mark entityReference quotation-mark                                        
                                        
; JSON syntax: adapted to URI restrictions from [RFC4627]                 
begin-object = BWS ( "{" / "%7B" ) BWS
end-object   = BWS ( "}" / "%7D" ) BWS

begin-array = BWS ( "[" / "%5B" ) BWS 
end-array   = BWS ( "]" / "%5D" ) BWS

quotation-mark  = DQUOTE / "%22"
name-separator  = BWS COLON BWS
value-separator = BWS COMMA BWS

primitiveLiteralInJSON = stringInJSON
                       / numberInJSON
                       / 'true' 
                       / 'false'
                       / 'null'

stringInJSON = quotation-mark *charInJSON quotation-mark
charInJSON   = qchar-unescaped  
             / qchar-JSON-special    
             / escape ( quotation-mark 
                      / escape
                      / ( "/" / "%2F" ) ; solidus         U+002F
                      / 'b'             ; backspace       U+0008                
                      / 'f'             ; form feed       U+000C
                      / 'n'             ; line feed       U+000A
                      / 'r'             ; carriage return U+000D
                      / 't'             ; tab             U+0009
                      / 'u' 4HEXDIG     ;                 U+XXXX
                      )

qchar-JSON-special = SP / ":" / "{" / "}" / "[" / "]" ; some agents put these unencoded into the query part of a URL

escape = "\" / "%5C"     ; reverse solidus U+005C

numberInJSON = [ "-" ] int [ frac ] [ exp ]
int          = "0" / ( oneToNine *DIGIT )
frac         = "." 1*DIGIT
exp          = "e" [ "-" / "+" ] 1*DIGIT


;------------------------------------------------------------------------------
; 5. Names and identifiers
;------------------------------------------------------------------------------

qualifiedTypeName = qualifiedEntityTypeName 
                  / qualifiedComplexTypeName
                  / qualifiedEnumerationTypeName
                  / primitiveTypeName 
                  / 'Collection' OPEN 
                    ( qualifiedEntityTypeName 
                    / qualifiedComplexTypeName
                    / qualifiedEnumerationTypeName 
                    / primitiveTypeName 
                    ) CLOSE

qualifiedEntityTypeName      = namespace "." entityTypeName
qualifiedComplexTypeName     = namespace "." complexTypeName
qualifiedEnumerationTypeName = namespace "." enumerationTypeName

; an alias is just a single-part namespace
namespace     = namespacePart *( "." namespacePart )
namespacePart = odataIdentifier

entitySetName       = odataIdentifier
namedEntity         = odataIdentifier          
entityTypeName      = odataIdentifier
complexTypeName     = odataIdentifier 
enumerationTypeName = odataIdentifier
enumerationMember   = odataIdentifier

odataIdentifier             = identifierLeadingCharacter *127identifierCharacter
identifierLeadingCharacter  = ALPHA / "_"            ; TODO: Any character from the Unicode categories L or Nl
identifierCharacter         = ALPHA / DIGIT / "_"    ; TODO: Any character from the Unicode categories L, Nl, Nd, Mn, Mc, Pc or Cf

primitiveTypeName = ['Edm.'] ( 'Binary'
                             / 'Boolean'
                             / 'Byte'
                             / 'Date' 
                             / 'DateTimeOffset'
                             / 'Decimal'
                             / 'Double'
                             / 'Duration' 
                             / 'Guid' 
                             / 'Int16'
                             / 'Int32'
                             / 'Int64'
                             / 'SByte'
                             / 'Single'
                             / 'Stream'
                             / 'String'
                             / 'TimeOfDay'
                             / abstractSpatialTypeName [ concreteSpatialTypeName ] 
                             )
abstractSpatialTypeName = 'Geography'
                        / 'Geometry'
concreteSpatialTypeName = 'Collection'
                        / 'LineString'
                        / 'MultiLineString'
                        / 'MultiPoint'
                        / 'MultiPolygon'
                        / 'Point'
                        / 'Polygon'

property = primitiveProperty  
         / primitiveColProperty 
         / complexProperty 
         / complexColProperty 
         / streamProperty

primitiveProperty       = primitiveKeyProperty / primitiveNonKeyProperty
primitiveKeyProperty    = odataIdentifier
primitiveNonKeyProperty = odataIdentifier
primitiveColProperty    = odataIdentifier
complexProperty         = odataIdentifier
complexColProperty      = odataIdentifier
streamProperty          = odataIdentifier

navigationProperty          = entityNavigationProperty / entityColNavigationProperty  
entityNavigationProperty    = odataIdentifier
entityColNavigationProperty = odataIdentifier

entityContainer = odataIdentifier

action       = odataIdentifier
actionImport = odataIdentifier

function = entityFunction 
         / entityColFunction 
         / complexFunction 
         / complexColFunction 
         / primitiveFunction 
         / primitiveColFunction
         
entityFunction       = odataIdentifier
entityColFunction    = odataIdentifier
complexFunction      = odataIdentifier
complexColFunction   = odataIdentifier
primitiveFunction    = odataIdentifier
primitiveColFunction = odataIdentifier

entityFunctionImport       = odataIdentifier
entityColFunctionImport    = odataIdentifier
complexFunctionImport      = odataIdentifier
complexColFunctionImport   = odataIdentifier
primitiveFunctionImport    = odataIdentifier
primitiveColFunctionImport = odataIdentifier


;------------------------------------------------------------------------------
; 6. Literal Data Values
;------------------------------------------------------------------------------

primitiveLiteral = null 
                 / decimal 
                 / single 
                 / double 
                 / sbyte 
                 / byte 
                 / int16 
                 / int32 
                 / int64 
                 / binary 
                 / date
                 / dateTimeOffset 
                 / duration
                 / guid 
                 / string 
                 / timeOfDay 
                 / boolean 
                 / enum
                 / geographyCollection 
                 / geographyLineString 
                 / geographyMultiLineString 
                 / geographyMultiPoint 
                 / geographyMultiPolygon 
                 / geographyPoint 
                 / geographyPolygon 
                 / geometryCollection 
                 / geometryLineString 
                 / geometryMultiLineString 
                 / geometryMultiPoint 
                 / geometryMultiPolygon 
                 / geometryPoint 
                 / geometryPolygon 

null = 'null' [ SQUOTE qualifiedTypeName SQUOTE ] 
       ; The optional qualifiedTypeName is used to specify what type this null value should be considered. 
       ; Knowing the type is useful for function overload resolution purposes 
                                                
binary  = ( 'X' / "binary" ) SQUOTE binaryBody SQUOTE ; Note: 'X' is case sensitive, "binary" is not
binaryBody = *(2HEXDIG)

boolean = ( "true" / "1" ) / ( "false" / "0" )

decimal     = decimalBody [ "m" ]
decimalBody = [SIGN] 1*DIGIT ["." 1*DIGIT]

double      = doubleBody [ "d" ] / nanInfinity
doubleBody  = decimalBody [ "e" [SIGN] 1*DIGIT ] ; TODO: restrict range

single      = singleBody [ "f" ] / nanInfinity
singleBody  = decimalBody [ "e" [SIGN] 1*DIGIT ] ; TODO: restrict range

nanInfinity = 'NaN' / '-INF' / 'INF'

guid     = "guid" SQUOTE guidBody SQUOTE
guidBody = 8HEXDIG "-" 4HEXDIG "-" 4HEXDIG "-" 4HEXDIG "-" 12HEXDIG 

byte  = 1*3DIGIT ; numbers in the range from 0 to 255
sbyte = [ sign ] 1*3DIGIT ; numbers in the range from -128 to 127
int16 = [ sign ] 1*5DIGIT ; numbers in the range from -32768 to 32767        
int32 = [ sign ] 1*10DIGIT ; numbers in the range from -2147483648 to 2147483647
int64 = int64Body [ "L" ] 
int64Body = [ sign ] 1*19DIGIT ; numbers in the range from -9223372036854775808 to 9223372036854775807

string           = SQUOTE *( SQUOTE-in-string / pchar-no-SQUOTE ) SQUOTE
SQUOTE-in-string = SQUOTE SQUOTE ; two quotes represent one within string literal

date     = "date" SQUOTE dateBody SQUOTE
dateBody = year "-" month "-" day

dateTimeOffset     = "datetimeoffset" SQUOTE dateTimeOffsetBody SQUOTE
dateTimeOffsetBody = year "-" month "-" day "T" hour ":" minute [ ":" second [ "." fractionalSeconds ] ] ( "Z" / sign hour ":" minute )

duration     = "duration" SQUOTE durationBody SQUOTE
durationBody = [ sign ] "P" [ 1*DIGIT "D" ] [ "T" [ 1*DIGIT "H" ] [ 1*DIGIT "M" ] [ 1*DIGIT [ "." 1*DIGIT ] "S" ] ]
     ; the above is an approximation of the rules for an xml dayTimeDuration.
     ; see the lexical representation for dayTimeDuration in http://www.w3.org/TR/xmlschema11-2#dayTimeDuration for more information

timeOfDay     = "timeofday" SQUOTE timeOfDayBody SQUOTE 
timeOfDayBody = hour ":" minute [ ":" second [ "." fractionalSeconds ] ]
 
oneToNine       = "1" / "2" / "3" / "4" / "5" / "6" / "7" / "8" / "9" 
zeroToFiftyNine = ( "0" / "1" / "2" / "3" / "4" / "5" ) DIGIT
year  = [ "-" ] ( "0" 3DIGIT / oneToNine 3*DIGIT )
month = "0" oneToNine
      / "1" ( "0" / "1" / "2" )
day   = ( "0" / "1" / "2" ) oneToNine
      / "3" ( "0" / "1" )
hour   = ( "0" / "1" ) DIGIT
       / "2" ( "1" / "2" / "3" ) 
minute = zeroToFiftyNine
second = zeroToFiftyNine       
fractionalSeconds = 1*12DIGIT

enum      = qualifiedEnumerationTypeName SQUOTE enumBody SQUOTE
enumBody  = enumValue *( COMMA enumValue )
enumValue = enumerationMember / int64Body

geographyCollection   = geographyPrefix fullCollectionLiteral SQUOTE
fullCollectionLiteral = sridLiteral collectionLiteral
collectionLiteral     = "Collection(" geoLiteral *( COMMA geoLiteral ) CLOSE
geoLiteral            = collectionLiteral
                      / lineStringLiteral
                      / multiPointLiteral
                      / multiLineStringLiteral
                      / multiPolygonLiteral
                      / pointLiteral
                      / polygonLiteral

geographyLineString   = geographyPrefix fullLineStringLiteral SQUOTE
fullLineStringLiteral = sridLiteral lineStringLiteral
lineStringLiteral     = "LineString" lineStringData
lineStringData        = OPEN positionLiteral 1*( COMMA positionLiteral ) CLOSE

geographyMultiLineString   = geographyPrefix fullMultiLineStringLiteral SQUOTE
fullMultiLineStringLiteral = sridLiteral multiLineStringLiteral
multiLineStringLiteral     = "MultiLineString(" [ lineStringData *( COMMA lineStringData ) ] CLOSE

geographyMultiPoint   = geographyPrefix fullMultiPointLiteral SQUOTE
fullMultiPointLiteral = sridLiteral multiPointLiteral
multiPointLiteral     = "MultiPoint(" [ pointData *( COMMA pointData ) ] CLOSE

geographyMultiPolygon   = geographyPrefix fullMultiPolygonLiteral SQUOTE
fullMultiPolygonLiteral = sridLiteral multiPolygonLiteral
multiPolygonLiteral     = "MultiPolygon(" [ polygonData *( COMMA polygonData ) ] CLOSE

geographyPoint   = geographyPrefix fullPointLiteral SQUOTE
fullPointLiteral = sridLiteral pointLiteral
sridLiteral      = "SRID" EQ 1*5DIGIT SEMI
pointLiteral     ="Point" pointData
pointData        = OPEN positionLiteral CLOSE
positionLiteral  = double SP double  ; longitude, then latitude

geographyPolygon   = geographyPrefix fullPolygonLiteral SQUOTE
fullPolygonLiteral = sridLiteral polygonLiteral
polygonLiteral     = "Polygon" polygonData
polygonData        = OPEN ringLiteral *( COMMA ringLiteral ) CLOSE
ringLiteral        = OPEN positionLiteral *( COMMA positionLiteral ) CLOSE
                   ; Within each ringLiteral, the first and last positionLiteral elements MUST be an exact syntactic match to each other.
                   ; Within the polygonData, the ringLiterals MUST specify their points in appropriate winding order. 
                   ; In order of traversal, points to the left side of the ring are interpreted as being in the polygon.

geometryCollection      = geometryPrefix fullCollectionLiteral      SQUOTE
geometryLineString      = geometryPrefix fullLineStringLiteral      SQUOTE
geometryMultiLineString = geometryPrefix fullMultiLineStringLiteral SQUOTE
geometryMultiPoint      = geometryPrefix fullMultiPointLiteral      SQUOTE
geometryMultiPolygon    = geometryPrefix fullMultiPolygonLiteral    SQUOTE
geometryPoint           = geometryPrefix fullPointLiteral           SQUOTE
geometryPolygon         = geometryPrefix fullPolygonLiteral         SQUOTE

geographyPrefix = "geography" SQUOTE
geometryPrefix  = "geometry" SQUOTE


;------------------------------------------------------------------------------
; 7. Punctuation
;------------------------------------------------------------------------------

OWS =  *( SP / HTAB / "%20" / "%09" )  ; "optional" whitespace 
RWS = 1*( SP / HTAB / "%20" / "%09" )  ; "required" whitespace 
BWS = OWS                              ; "bad" whitespace 

AT     = "@" / "%40"
COLON  = ":" / "%3A"
COMMA  = "," / "%2C"
EQ     = "="
SIGN   = "+" / "%2B" / "-"
SEMI   = ";" / "%3B"
STAR   = "*" / "%2A"
SQUOTE = "'" / "%27"

OPEN  = "(" / "%28"
CLOSE = ")" / "%29"


;------------------------------------------------------------------------------
; A. URI syntax [RFC3986]
;------------------------------------------------------------------------------

;URI           = scheme ":" hier-part [ "?" query ] [ "#" fragment ]
;hier-part     = "//" authority path-abempty
;              / path-absolute
;              / path-rootless
;              / path-empty
;URI-reference = URI / relative-ref
;absolute-URI  = scheme ":" hier-part [ "?" query ]
;relative-ref  = relative-part [ "?" query ] [ "#" fragment ]
;relative-part = "//" authority path-abempty
;              / path-absolute
;              / path-noscheme
;              / path-empty
;scheme        = ALPHA *( ALPHA / DIGIT / "+" / "-" / "." )
;authority     = [ userinfo "@" ] host [ ":" port ]
;userinfo      = *( unreserved / pct-encoded / sub-delims / ":" )
host          = IP-literal / IPv4address / reg-name
port          = *DIGIT
IP-literal    = "[" ( IPv6address / IPvFuture  ) "]"
IPvFuture     = "v" 1*HEXDIG "." 1*( unreserved / sub-delims / ":" )
IPv6address   =                            6( h16 ":" ) ls32
                 /                       "::" 5( h16 ":" ) ls32
                 / [               h16 ] "::" 4( h16 ":" ) ls32
                 / [ *1( h16 ":" ) h16 ] "::" 3( h16 ":" ) ls32
                 / [ *2( h16 ":" ) h16 ] "::" 2( h16 ":" ) ls32
                 / [ *3( h16 ":" ) h16 ] "::"    h16 ":"   ls32
                 / [ *4( h16 ":" ) h16 ] "::"              ls32
                 / [ *5( h16 ":" ) h16 ] "::"              h16
                 / [ *6( h16 ":" ) h16 ] "::"
h16           = 1*4HEXDIG
ls32          = ( h16 ":" h16 ) / IPv4address
IPv4address   = dec-octet "." dec-octet "." dec-octet "." dec-octet
dec-octet     = "1" 2DIGIT            ; 100-199
              / "2" %x30-34 DIGIT     ; 200-249
              / "25" %x30-35          ; 250-255
              / %x31-39 DIGIT         ; 10-99
              / DIGIT                 ; 0-9
reg-name      = *( unreserved / pct-encoded / sub-delims )
;path          = path-abempty    ; begins with "/" or is empty
;              / path-absolute   ; begins with "/" but not "//"
;              / path-noscheme   ; begins with a non-colon segment
;              / path-rootless   ; begins with a segment
;              / path-empty      ; zero characters
;path-abempty  = *( "/" segment )
;path-absolute = "/" [ segment-nz *( "/" segment ) ]
;path-noscheme = segment-nz-nc *( "/" segment )
;path-rootless = segment-nz *( "/" segment )
;path-empty    = ""
;segment       = *pchar
segment-nz    = 1*pchar
;segment-nz-nc = 1*( unreserved / pct-encoded / sub-delims / "@" ) ; non-zero-length segment without any colon ":"
pchar         = unreserved / pct-encoded / sub-delims / ":" / "@"
;query         = *( pchar / "/" / "?" )
;fragment      = *( pchar / "/" / "?" )
pct-encoded   = "%" HEXDIG HEXDIG
unreserved    = ALPHA / DIGIT / "-" / "." / "_" / "~"
;reserved      = gen-delims / sub-delims
;gen-delims    = ":" / "/" / "?" / "#" / "[" / "]" / "@"
;sub-delims    = "!" / "$" / "&" / "'" / "(" / ")" / "*" / "+" / "," / ";" / "="
sub-delims     =       "$" / "&" / "'" /                                     "=" / other-delims
other-delims   = "!" /                   "(" / ")" / "*" / "+" / "," / ";"

pchar-no-SQUOTE       = unreserved / pct-encoded-no-SQUOTE / other-delims / "$" / "&" / "=" / ":" / "@"
pct-encoded-no-SQUOTE = "%" ( "0" / "1" /   "3" / "4" / "5" / "6" / "8" / "9" / A-to-F ) HEXDIG 
                      / "%" "2" ( "0" / "1" / "2" / "3" / "4" / "5" / "6" /   "8" / "9" / A-to-F )

qchar-no-AMP              = unreserved / pct-encoded / other-delims / ":" / "@" / "/" / "?" / "$" / "'" / "="
qchar-no-AMP-EQ           = unreserved / pct-encoded / other-delims / ":" / "@" / "/" / "?" / "$" / "'"
qchar-no-AMP-EQ-AT-DOLLAR = unreserved / pct-encoded / other-delims / ":" /       "/" / "?" /       "'"

qchar-unescaped       = unreserved / pct-encoded-unescaped / other-delims / ":" / "@" / "/" / "?" / "$" / "'" / "="
pct-encoded-unescaped = "%" ( "0" / "1" /   "3" / "4" /   "6" / "8" / "9" / A-to-F ) HEXDIG 
                      / "%" "2" ( "0" / "1" /   "3" / "4" / "5" / "6" / "7" / "8" / "9" / A-to-F ) 
                      / "%" "5" ( DIGIT / "A" / "B" /   "D" / "E" / "F" )

qchar-no-AMP-DQUOTE   = qchar-unescaped 
                      / escape ( escape / quotation-mark )
                     
                      
;------------------------------------------------------------------------------
; B. ABNF core definitions [RFC5234]
;------------------------------------------------------------------------------
ALPHA  = %x41-5A / %x61-7A 
DIGIT  = %x30-39 
HEXDIG = DIGIT / A-to-F
A-to-F = "A" / "B" / "C" / "D" / "E" / "F" 
DQUOTE = %x22
SP     = %x20 
HTAB   = %x09 
;WSP    = SP / HTAB 
;LWSP = *(WSP / CRLF WSP) 
;VCHAR = %x21-7E 
;CHAR = %x01-7F
;LOCTET = %x00-FF 
;CR     = %x0D 
;LF     = %x0A 
;CRLF   = CR LF
;BIT = "0" / "1" 


;------------------------------------------------------------------------------
; C. UTF-8 syntax [RFC3629]
;------------------------------------------------------------------------------

;UTF8-octets = *( UTF8-char )
;UTF8-char   = UTF8-1 / UTF8-2 / UTF8-3 / UTF8-4
;UTF8-1      = %x00-7F
;UTF8-2      = %xC2-DF UTF8-tail
;UTF8-3      = %xE0 %xA0-BF UTF8-tail / %xE1-EC 2( UTF8-tail ) /
;              %xED %x80-9F UTF8-tail / %xEE-EF 2( UTF8-tail )
;UTF8-4      = %xF0 %x90-BF 2( UTF8-tail ) / %xF1-F3 3( UTF8-tail ) /
;              %xF4 %x80-8F 2( UTF8-tail )
;UTF8-tail   = %x80-BF


;------------------------------------------------------------------------------
; End of odata-abnf-v4.0-wd01
;------------------------------------------------------------------------------